"""
GitHub文件上传模块
使用PyGithub库实现文件的自动上传和更新
"""
import os
import logging
from typing import Optional, Dict, Any
from datetime import datetime

try:
    from github import Github, GithubException, UnknownObjectException
    from github.Repository import Repository
    from github.ContentFile import ContentFile
except ImportError:
    raise ImportError("请安装PyGithub库: pip install PyGithub")


class GitHubUploader:
    """GitHub文件上传器"""
    
    def __init__(self, token: str, repo_name: str, branch: str = 'main'):
        """
        初始化GitHub上传器
        
        Args:
            token: GitHub Personal Access Token
            repo_name: 仓库名称（格式: username/repo）
            branch: 分支名称，默认为main
        
        Raises:
            ValueError: 当token或repo_name为空时
            GithubException: 当认证失败或仓库不存在时
        """
        if not token:
            raise ValueError("GitHub token不能为空")
        if not repo_name:
            raise ValueError("GitHub仓库名称不能为空")
        
        self.token = token
        self.repo_name = repo_name
        self.branch = branch
        self.logger = logging.getLogger(__name__)
        
        try:
            # 初始化GitHub客户端
            self.github = Github(token)
            
            # 获取仓库对象
            self.repo: Repository = self.github.get_repo(repo_name)
            
            self.logger.info(f"成功连接到GitHub仓库: {repo_name}")
            self.logger.info(f"仓库描述: {self.repo.description or '无'}")
            self.logger.info(f"默认分支: {self.repo.default_branch}")
            
        except GithubException as e:
            self.logger.error(f"GitHub认证或仓库访问失败: {e}")
            raise
    
    def file_exists(self, file_path: str) -> bool:
        """
        检查文件是否存在于仓库中
        
        Args:
            file_path: 仓库中的文件路径
        
        Returns:
            bool: 文件是否存在
        """
        try:
            self.repo.get_contents(file_path, ref=self.branch)
            return True
        except UnknownObjectException:
            return False
        except GithubException as e:
            self.logger.warning(f"检查文件存在性时出错: {e}")
            return False
    
    def get_file_content(self, file_path: str) -> Optional[ContentFile]:
        """
        获取仓库中文件的当前内容
        
        Args:
            file_path: 仓库中的文件路径
        
        Returns:
            Optional[ContentFile]: 文件对象，如果文件不存在返回None
        """
        try:
            content = self.repo.get_contents(file_path, ref=self.branch)
            self.logger.debug(f"成功获取文件内容: {file_path}")
            return content
        except UnknownObjectException:
            self.logger.debug(f"文件不存在: {file_path}")
            return None
        except GithubException as e:
            self.logger.error(f"获取文件内容失败: {e}")
            return None
    
    def _read_local_file(self, file_path: str) -> Optional[str]:
        """
        读取本地文件内容
        
        Args:
            file_path: 本地文件路径
        
        Returns:
            Optional[str]: 文件内容，读取失败返回None
        """
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            self.logger.debug(f"成功读取本地文件: {file_path}, 大小: {len(content)} 字符")
            return content
        except Exception as e:
            self.logger.error(f"读取本地文件失败: {file_path}, 错误: {e}")
            return None
    
    def _generate_commit_message(self, file_path: str, node_count: int = 0, countries: str = '') -> str:
        """
        生成commit信息
        
        Args:
            file_path: 文件路径
            node_count: 节点数量
            countries: 国家列表
        
        Returns:
            str: 格式化的commit信息
        """
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
        message_parts = [
            f"Update {os.path.basename(file_path)} - {timestamp}",
            ""
        ]
        
        if node_count > 0:
            message_parts.append(f"- Total nodes: {node_count}")
        
        if countries:
            message_parts.append(f"- Countries: {countries}")
        
        message_parts.append("- Generated by automated script")
        
        return '\n'.join(message_parts)
    
    def _parse_node_info(self, content: str) -> Dict[str, Any]:
        """
        解析节点信息
        
        Args:
            content: 文件内容
        
        Returns:
            Dict: 包含节点数量和国家信息的字典
        """
        info = {
            'node_count': 0,
            'countries': set()
        }
        
        if not content:
            return info
        
        # 按逗号分割节点
        nodes = content.split(',')
        info['node_count'] = len(nodes)
        
        # 提取国家代码
        for node in nodes:
            if '#' in node:
                # 格式: IP:端口#国家-城市
                parts = node.split('#')
                if len(parts) > 1:
                    country_city = parts[1]
                    if '-' in country_city:
                        country = country_city.split('-')[0]
                        info['countries'].add(country)
        
        return info
    
    def upload_file(self, local_path: str, target_path: str, commit_message: Optional[str] = None) -> bool:
        """
        上传文件到GitHub仓库
        
        Args:
            local_path: 本地文件路径
            target_path: GitHub仓库中的目标路径
            commit_message: 提交信息（可选，默认自动生成）
        
        Returns:
            bool: 上传是否成功
        """
        try:
            # 检查本地文件是否存在
            if not os.path.exists(local_path):
                self.logger.error(f"本地文件不存在: {local_path}")
                return False
            
            # 读取本地文件内容
            content = self._read_local_file(local_path)
            if content is None:
                return False
            
            # 解析节点信息
            node_info = self._parse_node_info(content)
            
            # 生成commit信息
            if commit_message is None:
                countries_str = ', '.join(sorted(node_info['countries']))
                commit_message = self._generate_commit_message(
                    target_path,
                    node_info['node_count'],
                    countries_str
                )
            
            self.logger.info(f"准备上传文件: {local_path} -> {target_path}")
            self.logger.info(f"文件大小: {len(content)} 字符")
            self.logger.info(f"节点数量: {node_info['node_count']}")
            if node_info['countries']:
                self.logger.info(f"国家分布: {', '.join(sorted(node_info['countries']))}")
            
            # 检查文件是否已存在
            existing_file = self.get_file_content(target_path)
            
            if existing_file:
                # 更新现有文件
                self.logger.info(f"文件已存在，执行更新操作")
                result = self.repo.update_file(
                    path=target_path,
                    message=commit_message,
                    content=content,
                    sha=existing_file.sha,
                    branch=self.branch
                )
                self.logger.info(f"文件更新成功")
            else:
                # 创建新文件
                self.logger.info(f"文件不存在，执行创建操作")
                result = self.repo.create_file(
                    path=target_path,
                    message=commit_message,
                    content=content,
                    branch=self.branch
                )
                self.logger.info(f"文件创建成功")
            
            # 输出commit信息
            commit = result['commit']
            self.logger.info(f"Commit SHA: {commit.sha}")
            self.logger.info(f"Commit URL: {commit.html_url}")
            if commit and commit.commit and commit.commit.message:
                self.logger.info(f"Commit 信息: {commit.commit.message.split(chr(10))[0]}")
            else:
                self.logger.info("Commit 信息: 无法获取")
            
            return True
            
        except GithubException as e:
            self.logger.error(f"GitHub API错误: {e.status} - {e.data.get('message', str(e))}")
            
            # 处理特定错误
            if e.status == 401:
                self.logger.error("认证失败，请检查GitHub Token是否有效")
            elif e.status == 403:
                self.logger.error("权限不足或API限流，请检查Token权限或稍后重试")
            elif e.status == 404:
                self.logger.error("仓库或分支不存在，请检查配置")
            elif e.status == 422:
                self.logger.error("请求参数错误，请检查文件路径和内容")
            
            return False
            
        except Exception as e:
            self.logger.error(f"上传文件时发生未知错误: {e}", exc_info=True)
            return False
    
    def get_rate_limit(self) -> Dict[str, Any]:
        """
        获取API速率限制信息
        
        Returns:
            Dict: 包含速率限制信息的字典
        """
        try:
            rate_limit = self.github.get_rate_limit()
            core = rate_limit.core
            
            info = {
                'limit': core.limit,
                'remaining': core.remaining,
                'reset': core.reset.strftime('%Y-%m-%d %H:%M:%S')
            }
            
            self.logger.debug(f"API速率限制: {info['remaining']}/{info['limit']}, 重置时间: {info['reset']}")
            return info
            
        except Exception as e:
            self.logger.warning(f"获取速率限制信息失败: {e}")
            return {}
    
    def close(self):
        """关闭GitHub连接"""
        try:
            if hasattr(self, 'github'):
                self.github.close()
                self.logger.debug("GitHub连接已关闭")
        except Exception as e:
            self.logger.warning(f"关闭GitHub连接时出错: {e}")